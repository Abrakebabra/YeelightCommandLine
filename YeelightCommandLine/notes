
Do:
 - Search udp message to multicast address
 - Receive udp response from multicast address
    - Get IP Port search message was sent from
    - Listen to that IP Port for response
    - Get individual light properties
    - Create new tcp connection to each light
    - Save the light connection and properties
- Light connection:
     - Save properties
     - Save connection
     - Encode JSON

    As a loop in a separate thread
     - Listen for responses
     - When responses are received, filter between
         - Confirmation of received command messages
         - Error messages
         - Change of state


     - Music mode?  Create separate TCP connection
     - Color Flow?
 - Work on main program with commands

 - Make a readme

 - ensure only method enum is passed on as valid method
3

- // case "adjust_ct": - This doesn't make sense
// case "adjust_color": - This doesn't make sense
Asked yeelight developer forum.
https://forum.yeelight.com/t/topic/17006


Fix:
 - Light should actually be a reference type in case it's ever copied.


Learn:

- Network classes
    - New socket and connect
    - Send and receive both UDP and TCP
    - Isolate socket from NWEndpoint.hostport
    - Listen on that port
    - Handling program flow with the network functions on a different queue/thread

 - Dispatch Queues and Groups
    - Async, sync, semaphores and QoS

 - Enumerations
    - How to use them

 - Switch Cases
    - When and how to use them

 - Structs
    - What they are, when they're used, what for

 - Error Handing and Do-Catch with Guard Try

 - Handling JSON files and nested JSON
    - https://developer.apple.com/swift/blog/?id=37

 - Closures, escaping closures and completion handlers, typealias







About Lights

Responses:
Actually provides 2 responses.
{"id":1,"result":["ok"]}
{"method":"props","params":{"ct":6500}}
